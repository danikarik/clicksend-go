// Code generated by go-swagger; DO NOT EDIT.

package sms

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new sms API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for sms API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
SMSCancelAllPut updates all scheduled message as cancelled

Update all scheduled message as cancelled
*/
func (a *Client) SMSCancelAllPut(params *SMSCancelAllPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSCancelAllPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSCancelAllPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsCancelAllPut",
		Method:             "PUT",
		PathPattern:        "/sms/cancel-all",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSCancelAllPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSCancelAllPutOK), nil

}

/*
SMSCancelByMessageIDPut updates scheduled message as cancelled

Update scheduled message as cancelled
*/
func (a *Client) SMSCancelByMessageIDPut(params *SMSCancelByMessageIDPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSCancelByMessageIDPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSCancelByMessageIDPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsCancelByMessageIdPut",
		Method:             "PUT",
		PathPattern:        "/sms/{message_id}/cancel",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSCancelByMessageIDPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSCancelByMessageIDPutOK), nil

}

/*
SMSHistoryExportGet exports all sms history

Export all sms history
*/
func (a *Client) SMSHistoryExportGet(params *SMSHistoryExportGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSHistoryExportGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSHistoryExportGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsHistoryExportGet",
		Method:             "GET",
		PathPattern:        "/sms/history/export",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSHistoryExportGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSHistoryExportGetOK), nil

}

/*
SMSHistoryGet gets all sms history

Get all sms history
*/
func (a *Client) SMSHistoryGet(params *SMSHistoryGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSHistoryGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSHistoryGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsHistoryGet",
		Method:             "GET",
		PathPattern:        "/sms/history",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSHistoryGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSHistoryGetOK), nil

}

/*
SMSInboundGet gets all inbound sms

Get all inbound sms
*/
func (a *Client) SMSInboundGet(params *SMSInboundGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSInboundGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSInboundGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsInboundGet",
		Method:             "GET",
		PathPattern:        "/sms/inbound",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSInboundGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSInboundGetOK), nil

}

/*
SMSInboundPost creates inbound sms

Create inbound sms
*/
func (a *Client) SMSInboundPost(params *SMSInboundPostParams, authInfo runtime.ClientAuthInfoWriter) (*SMSInboundPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSInboundPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsInboundPost",
		Method:             "POST",
		PathPattern:        "/sms/inbound",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSInboundPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSInboundPostOK), nil

}

/*
SMSInboundReadByMessageIDPut marks inbound SMS as read

Mark specific inbound SMS as read
*/
func (a *Client) SMSInboundReadByMessageIDPut(params *SMSInboundReadByMessageIDPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSInboundReadByMessageIDPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSInboundReadByMessageIDPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsInboundReadByMessageIdPut",
		Method:             "PUT",
		PathPattern:        "/sms/inbound-read/{message_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSInboundReadByMessageIDPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSInboundReadByMessageIDPutOK), nil

}

/*
SMSInboundReadPut marks inbound SMS as read

Mark all inbound SMS as read optionally before a certain date
*/
func (a *Client) SMSInboundReadPut(params *SMSInboundReadPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSInboundReadPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSInboundReadPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsInboundReadPut",
		Method:             "PUT",
		PathPattern:        "/sms/inbound-read",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSInboundReadPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSInboundReadPutOK), nil

}

/*
SMSPricePost calculates sms price

Calculate sms price
*/
func (a *Client) SMSPricePost(params *SMSPricePostParams, authInfo runtime.ClientAuthInfoWriter) (*SMSPricePostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSPricePostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsPricePost",
		Method:             "POST",
		PathPattern:        "/sms/price",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSPricePostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSPricePostOK), nil

}

/*
SMSReceiptsByMessageIDGet gets a specific delivery receipt

Get a Specific Delivery Receipt
*/
func (a *Client) SMSReceiptsByMessageIDGet(params *SMSReceiptsByMessageIDGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSReceiptsByMessageIDGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSReceiptsByMessageIDGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsReceiptsByMessageIdGet",
		Method:             "GET",
		PathPattern:        "/sms/receipts/{message_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSReceiptsByMessageIDGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSReceiptsByMessageIDGetOK), nil

}

/*
SMSReceiptsGet gets all delivery receipts

Get all delivery receipts
*/
func (a *Client) SMSReceiptsGet(params *SMSReceiptsGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSReceiptsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSReceiptsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsReceiptsGet",
		Method:             "GET",
		PathPattern:        "/sms/receipts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSReceiptsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSReceiptsGetOK), nil

}

/*
SMSReceiptsPost adds a delivery receipt

Add a delivery receipt
*/
func (a *Client) SMSReceiptsPost(params *SMSReceiptsPostParams, authInfo runtime.ClientAuthInfoWriter) (*SMSReceiptsPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSReceiptsPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsReceiptsPost",
		Method:             "POST",
		PathPattern:        "/sms/receipts",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSReceiptsPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSReceiptsPostOK), nil

}

/*
SMSReceiptsReadPut marks delivery receipts as read

Mark delivery receipts as read
*/
func (a *Client) SMSReceiptsReadPut(params *SMSReceiptsReadPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSReceiptsReadPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSReceiptsReadPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsReceiptsReadPut",
		Method:             "PUT",
		PathPattern:        "/sms/receipts-read",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSReceiptsReadPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSReceiptsReadPutOK), nil

}

/*
SMSSendPost sends sms message s


# Send one or more SMS messages

You can post up to 1000 messages with each API call. You can send to a mix of contacts and contact lists, as long as the total number of recipients is up to 1000.
The response contains status and details for each recipient.

*Refer to [Application Status Codes](https://dashboard.clicksend.com/#/signup/step1/) for the possible response message status strings.*

*/
func (a *Client) SMSSendPost(params *SMSSendPostParams, authInfo runtime.ClientAuthInfoWriter) (*SMSSendPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSSendPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsSendPost",
		Method:             "POST",
		PathPattern:        "/sms/send",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSSendPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSSendPostOK), nil

}

/*
SMSTemplatesByTemplateIDDelete deletes sms template

Delete sms template
*/
func (a *Client) SMSTemplatesByTemplateIDDelete(params *SMSTemplatesByTemplateIDDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*SMSTemplatesByTemplateIDDeleteOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSTemplatesByTemplateIDDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsTemplatesByTemplateIdDelete",
		Method:             "DELETE",
		PathPattern:        "/sms/templates/{template_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSTemplatesByTemplateIDDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSTemplatesByTemplateIDDeleteOK), nil

}

/*
SMSTemplatesByTemplateIDPut updates sms template

Update sms template
*/
func (a *Client) SMSTemplatesByTemplateIDPut(params *SMSTemplatesByTemplateIDPutParams, authInfo runtime.ClientAuthInfoWriter) (*SMSTemplatesByTemplateIDPutOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSTemplatesByTemplateIDPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsTemplatesByTemplateIdPut",
		Method:             "PUT",
		PathPattern:        "/sms/templates/{template_id}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSTemplatesByTemplateIDPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSTemplatesByTemplateIDPutOK), nil

}

/*
SMSTemplatesGet gets lists of all sms templates

Get lists of all sms templates
*/
func (a *Client) SMSTemplatesGet(params *SMSTemplatesGetParams, authInfo runtime.ClientAuthInfoWriter) (*SMSTemplatesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSTemplatesGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsTemplatesGet",
		Method:             "GET",
		PathPattern:        "/sms/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSTemplatesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSTemplatesGetOK), nil

}

/*
SMSTemplatesPost creates sms template

Create sms template
*/
func (a *Client) SMSTemplatesPost(params *SMSTemplatesPostParams, authInfo runtime.ClientAuthInfoWriter) (*SMSTemplatesPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSMSTemplatesPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "SmsTemplatesPost",
		Method:             "POST",
		PathPattern:        "/sms/templates",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SMSTemplatesPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SMSTemplatesPostOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
